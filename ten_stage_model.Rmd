---
title: "ten_stage_model"
author: ""
date: "2025-05-29"
output: html_document
---

README: code for running model simulations using a version of the model with 10 host size classes 

# functions

```{r}
# all functions for running eco-evo simulations with 10 host size classes

################## DEMOGRAPHIC RATE FUNCTIONS ####################### 

# these functions consist of:
# 1) functions describing relationships between host size and demographic rates and for calculating the average of these rates over specified size classes
# 2) functions describing the effects of the partner on host growth and mortality and the effects of the host on partner mortality

# relationship between individual host area and fecundity 
# Fmn = area at which the host become reproductively mature
# Fconst = baseline fecundity upon reaching reproductive maturity
# Fexp = rate at which fecundity increases exponentially with area
FofA <- function(A, Fmn, Fconst, Fexp){
  
  if(A < Fmn){
    f <- 0
  } else{
    
    f <- Fconst*exp(Fexp*(A-Fmn))
    
  }
  
}

FofA <- Vectorize(FofA, "A")


# function for calculating average fecundity within size range from x1 to x2 (where both are larger than the min size of reproduction)
# x1 = lower bound (host area) of integration range
# x2 = upper bound (host area) of integration range
# Fmn = area at which the host become reproductively mature
# Fconst = baseline fecundity upon reaching reproductive maturity
# Fexp = rate at which fecundity increases exponentially with area

avg_fec <- function(x1, x2, Fmn, Fconst, Fexp){
  
  if(Fexp != 0){
    # integral of c*exp(k*x) = c*1/k*exp(k*x)
    #avg <- (Fconst*exp(Fexp*x2)*1/Fexp-Fconst*exp(Fexp*x1)*1/Fexp)*1/(x2-x1)
    
    # integral of c*exp(k*(x-Fmn)) = c*1/k*exp(k*(x-Fmn))
    avg <- (Fconst*exp(Fexp*(x2-Fmn))*1/Fexp-Fconst*exp(Fexp*(x1-Fmn))*1/Fexp)*1/(x2-x1)
    
  } else{
    # integral of c*1 = (c*x2 - c*x1)
    avg <- (Fconst*x2 - Fconst*x1)/(x2-x1) # just Fconst
  }
  
  
  return(avg)
  
}



# growth: assume diameter follows von Bertalanffy growth curve

# use the basic growth equation to calculate the time it takes an individual to grow through a size class and use that to get the transition probability

# von Bert growth: L(t) = Linf*(1-exp(-k*t))

# age at length: log(1-L(t)/Linf)/-k

# make a function that takes the current size as an input and returns the size one month earlier (note this assumes even distribution within size classes)
# A = host area at time t + 1
# Dinf = max host diameter 
# g = von Bert growth rate

S1ofA <- function(A, Dinf, g){
  # first convert area to diameter
  # A = pi*(D/2)^2
  D <- sqrt(A/pi)*2
  
  # diameter one timestep earlier
  D0 <- (1-exp(log(1-D/Dinf)+g))*Dinf
  
  # area one timestep earlier:
  A0 <- pi*(D0/2)^2
  
  return(A0)
}

# then proportion that grow from A0 to >= A in class from A1 to A would be (A-A0)/(A-A1)



# function for calculating host mortality as a function of host area (declining exponential)
# A = host area
# a = how much higher the mortality of a host of area 0 is than the asymptotic mortality rate
# b = rate at which mortality declines with increasing host area
# c = asymptotic mortality rate approached by the largest individuals

MofA <- function(A, a,b, c){
  
  m <- a*exp(-b*A) + c # c = lowest mortality rate will go, c + a = mortality of smallest size
  
}

MofA <- Vectorize(MofA, "A")


# function for calculating average mortality within size range from x1 to x2
# x1 = lower bound (host area) of integration range
# x2 = upper bound (host area) of integration range
# a = how much higher the mortality of a host of area 0 is than the asymptotic mortality rate
# b = rate at which mortality declines with increasing host area
# c = asymptotic mortality rate approached by the largest individuals


avg_mort <- function(x1, x2, a, b, c){
  
  if(b !=0){
    # integral of a*exp(-bx) + c = a*-1/b*exp(-bx) + cx
    avg <- (a*-1/b*exp(-b*x2) + c*x2 +a*1/b*exp(-b*x1) - c*x1)*1/(x2-x1)
  } else{
    # integral of a*1 + c = (a + c)*x2 - (a + c)*x1
    avg <- ((a + c)*x2 - (a + c)*x1)/(x2-x1)
  }
  
  
  return(avg)
  
}


# Effects of partner on host and of host on partner 

# function for calculating asymptotic host mortality (c in MofA function) as a function of partner abundance
# c0 = baseline asymptotic mortality rate in absence of partner
# exp_c = rate at which the asymptotic mortality rate declines with partner abundance
# c_mn = lowest possible density independent mortality rate
# P = partner abundance (per host)

MofP <- function(c0, exp_c, c_mn, P){
  
  if(is.na(P)==T){
    c <- c0
  } else{
    c <- (c0-c_mn)*exp(-exp_c*P) + c_mn
  }
  
  return(c)
  
}



MofP <- Vectorize(MofP, "P")

# function for calculating host growth rate (g in S1ofA function) as a function of partner abundance
# g0 = baseline growth host rate in absence of partner
# exp_g = rate at which host growth rate increases with partner abundance
# g_mx = maximum host growth rate
# P = partner abundance (per host)

GofP <- function(g0, exp_g, g_mx, P){
  
  if(is.na(P)==T){
    g <- g0
  } else{
    g <- g0 + (g_mx-g0)*(1-exp(-exp_g*P))
  }
  
  return(g)
  
}



GofP <- Vectorize(GofP, "P")



# function for calculating Fconst as a function of partner abundance
# Fconst0 = baseline host fecundity in absence of partner
# exp_F = rate at which host fecunidty increases with partner abundance
# Fconst_mx = maximum baseline host fecundity
# P = partner abundance (per host)

FofP <- function(Fconst0, exp_F, Fconst_mx, P){
  
  if(is.na(P)==T){
    Fconst <- Fconst0
  } else{
    Fconst <- Fconst0 + (Fconst_mx-Fconst0)*(1-exp(-exp_F*P))
  }
  
  return(Fconst)
  
}

FofP <- Vectorize(FofP, "P")

# function for calculating partner density dependent mortality rate as a function of host area.
# K0 = partner density dependent mortality on a host of area 0
# slope_mP = controls rate at which partner DD mortality decreases with host area
# A = host area

MPofA <- function(K0, slope_mP, A){
  
  #mP <- 1/(slope_mP*A)
  
  mP <- 1/(slope_mP*A^(3/2) + K0)
  
  
  return(mP)
  
}

MPofA <- Vectorize(MPofA, "A")

# average this 
# x1 = lower bound (host area) of integration range
# x2 = upper bound (host area) of integration range
# K0 = partner density dependent mortality on a host of area 0
# slope_mP = controls rate at which partner DD mortality decreases with host area

avg_Pmort <- function(x1, x2, K0, slope_mP){
  
  # integral of 1/(slope_mP*A) is log(slope_mP*A)*1/slope_mP
  #avg <- (log(slope_mP*x2)*1/slope_mP - log(slope_mP*x1)*1/slope_mP)/(x2-x1)
  
  # integral of 1/(slope_mP*A^(3/2) + K0) is complicated, calculated using mathematica
  
  
  if(slope_mP == 0){
    
    avg <- 1/K0
    
  } else{
    
    if(K0 > 0){
      int.x2 <- 1/(3*slope_mP^(2/3)*K0^(1/3))*(log(abs(slope_mP^(2/3)*x2-slope_mP^(1/3)*K0^(1/3)*sqrt(x2)+K0^(2/3)))+2*sqrt(3)*atan((2*slope_mP^(1/3)*K0^(2/3)*sqrt(x2)-K0)/(sqrt(3)*K0))-2*log(abs(slope_mP*sqrt(x2)+slope_mP^(2/3)*K0^(1/3))))
      
      int.x1 <- 1/(3*slope_mP^(2/3)*K0^(1/3))*(log(abs(slope_mP^(2/3)*x1-slope_mP^(1/3)*K0^(1/3)*sqrt(x1)+K0^(2/3)))+2*sqrt(3)*atan((2*slope_mP^(1/3)*K0^(2/3)*sqrt(x1)-K0)/(sqrt(3)*K0))-2*log(abs(slope_mP*sqrt(x1)+slope_mP^(2/3)*K0^(1/3))))
      
    } else{
      int.x2 <- -2/(slope_mP*sqrt(x2))
      int.x1 <- -2/(slope_mP*sqrt(x1))
    }
    
    avg <- (int.x2 - int.x1)/(x2-x1)
    
  }
  
  
  
  return(avg)
  
}



########################### FUNCTIONS FOR 10 HOST STAGES ####################

# phi for 10 size classes where the smallest are juveniles
phi_fun10 <- function(phi, A_tots){
  
  # go to all size classes
  p1 <- A_tots/sum(A_tots)
  # go to adult size classes only
  p2 <- c(0, A_tots[2:10]/sum(A_tots[2:10]))
  
  p <- (1-phi)*p1 + phi*p2
  
  return(p)
  
  
}


# base model with 10 host stages

mod_fun10 <- function(tmax, P0, H0, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, 
                     eH, Apatch, z, phi){
  
  
  # unlist parameters
  # partner DD mortality
  K0 <- mP_pars$K0; slope_mP <- mP_pars$slope_mP
  
  # host dens-indep mortality
  a_n <- nH_pars$a_n; b_n <- nH_pars$b_n; c_n0 <- nH_pars$c_n0; exp_cn <- nH_pars$exp_cn; cn_mn <- nH_pars$cn_mn
  
  # host density dep mortality
  a_m <- mH_pars$a_m; b_m <- mH_pars$b_m; c_m <- mH_pars$c_m
  
  # host growth
  Dinf <- G_pars$Dinf; g0 <- G_pars$g0; exp_g <- G_pars$exp_g; g_mx <- G_pars$g_mx
  Dmin <- G_pars$Dmin
  
  # host fecundity
  Fmn <- F_pars$Fmn; Fconst <- F_pars$Fconst; Fexp <- F_pars$Fexp
  
  # calculate fixed parameters
  # boundaries of the host size classes
  Amax <- pi*(1/2*Dinf)^2
  Amin <- pi*(1/2*Dmin)^2
  
  Abounds <- c(Amin, seq(from = 0.1, to = 0.9, by = 0.1)*Amax, Amax)
  
  
  # midpoints (used for calculating area occupied by each class; same as avg area in each class)
  #A <- c((Amin+A12)/2, (A23+A12)/2, (Amax+A23)/2)
  A <- rep(NA, 10)
  for(aa in 1:10){
    A[aa] <- (Abounds[aa]+Abounds[aa+1])/2
  }
  
  # partner density dependent mortality in each size class (depend on areas in each class)
  #mP <- c(avg_Pmort(Amin, A12, K0, slope_mP), avg_Pmort(A12, A23, K0, slope_mP), avg_Pmort(A23, Amax, K0, slope_mP))
  mP <- rep(NA, 10)
  for(aa in 1:10){
    mP[aa] <- avg_Pmort(Abounds[aa], Abounds[aa+1], K0, slope_mP)
  }
  
  # host fecundities in each size class
  #FH <- c(0, avg_fec(A12, A23, Fmn, Fconst, Fexp), avg_fec(A23, Amax, Fmn, Fconst, Fexp))
  FH <- rep(NA, 10)
  FH[1] <- 0
  for(aa in 2:10){
    FH[aa] <- avg_fec(Abounds[aa], Abounds[aa+1], Fmn, Fconst, Fexp)
  }
  
  # host density dependent mortality rates in each size class
  #mH <- c(avg_mort(Amin, A12, a_m, b_m, c_m), avg_mort(A12, A23, a_m, b_m, c_m), avg_mort(A23, Amax, a_m, b_m, c_m))
  mH <- rep(NA, 10)
  for(aa in 1:10){
    mH[aa] <- avg_mort(Abounds[aa], Abounds[aa+1], a_m, b_m, c_m)
  }
  
  # vector of time steps
  # tset <- seq(from = 0, to = tmax, length.out = 100*tmax) # time steps for iterating over
  tset <- seq(from = 0, to = tmax, by = 1) # time steps for iterating over
  
  # holding matrices
  # host
  Hmat <- matrix(NA, nrow = length(A), ncol = length(tset))
  Hmat[ ,1] <- H0
  
  # partner
  Pmat <- matrix(NA, nrow = length(A), ncol = length(tset))
  Pmat[ ,1] <- P0
  
 
  for(i in 2:length(tset)){
    
    # calculate the area occupied
    Atot <- sum(A*Hmat[, i-1])
    
    # calculate the host growth rates as a function of P per unit host
    # P_per_H <- rep(NA, length(Hmat[, i-1]))
    g_i <- GofP(g0, exp_g, g_mx, Pmat[, i-1]/Hmat[, i-1])
    
    # calculate size class transitions
    # class 1 to 2:
    # A0_1 <- S1ofA(A12, Dinf, g_i[1])
    # G12 <- ifelse(A0_1 < Amin, 1, (A12-A0_1)/(A12-Amin)) # proportion that grew into next size class
    # # if area at previous timestep is less than Amin, say 100% of class 1 grew to class 2
    # 
    # # class 2 to 3: 
    # A0_2 <- S1ofA(A23, Dinf, g_i[2])
    # G23 <- ifelse(A0_2 < A12, 1, (A23-A0_2)/(A23-A12)) # proportion that grew into next size class
    # # if area at previous timestep is in size class 1 (A02 < A12), say 100% of class 2 grew to class 3
    # 
    # G <- c(G12, G23, 0)
    
    G <- rep(NA, 10)
    G[10] <- 0
    
    for(aa in 1:9){
      A0_aa <- S1ofA(Abounds[aa+1], Dinf, g_i[aa])
      G[aa] <- ifelse(A0_aa < Abounds[aa], 1, (Abounds[aa+1]-A0_aa)/(Abounds[aa+1]-Abounds[aa]))
    }
    
    
    # calculate host dens-indep mortality rates as a function of P per host
    c_n <- MofP(c_n0, exp_cn, cn_mn, Pmat[, i-1]/Hmat[, i-1])
    #nH <- c(avg_mort(Amin, A12, a_n, b_n, c_n[1]), avg_mort(A12, A23, a_n, b_n, c_n[2]), avg_mort(A23, Amax, a_n, b_n, c_n[3]))
    
    nH <- rep(NA, 10)
    for(aa in 1:10){
      nH[aa] <- avg_mort(Abounds[aa], Abounds[aa+1], a_n, b_n, c_n[aa])
    }
    
    # calculate the host growth and survival rates
    G_Ht <- G*max(0, 1-Atot/Apatch) # realized growth depends on how much room there is
    S_Ht <- exp(-(nH + mH*Atot/Apatch)) # mH*Atot/Apatch*Hmat[, i-1]
    
    # calculate the survival rates for the partner
    S_P <- rep(NA, 10)
    
    for(sss in 1:10){
      if(Hmat[sss,i-1] == 0){
        S_P[sss] <- 0
      } else{
        S_P[sss] <- exp(-(nP + mP[sss]*Pmat[sss, i-1]/Hmat[sss,i-1])) # mortality depends on P/H
      }
    }
    
    # make the host transition matrix
    T_H <- matrix(rep(0, length(S_Ht)^2), nrow = length(S_Ht), ncol = length(S_Ht))
    # fill in the first row (note fecundities are done separately below)
    T_H[1, 1] <- (1-G_Ht[1])*S_Ht[1]
    
    # make the fish transition matrix
    T_P <- matrix(rep(0, length(S_Ht)^2), nrow = length(S_Ht), ncol = length(S_Ht))
    # fill in the first row
    T_P[1, 1] <- (1-G_Ht[1])*S_P[1]*S_Ht[1]
    
    
    # fill in the rest
    for(mm in 2:length(S_Ht)){
      
      # host
      T_H[mm, mm] <- (1-G_Ht[mm])*S_Ht[mm] # surviving and staying put
      T_H[mm, mm-1] <- G_Ht[mm-1]*S_Ht[mm-1] # surviving and growing to next size class
      
      # partner
      T_P[mm, mm] <- (1-G_Ht[mm])*S_P[mm]*S_Ht[mm] # surviving and staying put
      T_P[mm, mm-1] <- G_Ht[mm-1]*S_P[mm-1]*S_Ht[mm-1] # surviving and growing to next size class
    }
    
    
    # calculate the new population sizes
    Hmat[, i] <- T_H %*% Hmat[, i-1]
    Pmat[, i] <- T_P %*% Pmat[, i-1]
    
    
    
    # new partner recruits: distribute across the size classes according to preference function
    # total recruits (depends on whether population is open or closed)
    Rtot <- z*sum(rP*Pmat[ ,i-1]) + (1-z)*eP
    
    # preferences
    
    if(sum(Hmat[, i-1])==0){ 
      pxset <- rep(0, 10) 
    } else{
      
      pxset <- phi_fun10(phi, A*Hmat[, i-1])
    } 
    
    
    # calculate recruit survival
    S_R <- rep(NA, 10)
    
    for(sss in 1:10){
      if(Hmat[sss,i-1] == 0){ # index here needs to match index used for P/H (i or i-1)
        S_R[sss] <- 0
      } else{
        S_R[sss] <- exp(-(nP + mP[sss]*Pmat[sss, i-1]/Hmat[sss, i-1]))
      }
    }
    
    # add new recruits 
    Pmat[, i] <- Pmat[, i] +  pxset*Rtot*S_R 
    
    # add new recruits for the host (depends on whether population is open or closed)
    Hmat[1, i] <- Hmat[1, i] + z*sum(FH*Hmat[ ,i-1])*max(0, 1-Atot/Apatch) + (1-z)*eH*max(0, 1-Atot/Apatch)
    
    
    
    
  }
  
  
  
  return(list(t = tset, H = Hmat, P = Pmat))
  
}




# ternary search algorithm for finding the ecological optimum phi value
# left0 = initial leftmost value of phi
# right0 = initial rightmost value of phi
# error_tol = error tolerance for optimum value
# eqtol = tolerance level for whether model has equilibrated (prop difference btw abundance at time tmax and time tmax-10)

phiTSA_fun10 <- function(left0, right0, error_tol, eqtol, tmax, P0, H0, rP, nP, mP_pars, eP,     nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z, phi){
  
  # assign the initial upper and lower phi values
  left <- left0
  right <- right0
  
  # areas for calculating total area occupied
  Amax <- pi*(1/2*G_pars$Dinf)^2
  Amin <- pi*(1/2*G_pars$Dmin)^2
  
  # size class boundaries
  Abounds <- c(Amin, seq(from = 0.1, to = 0.9, by = 0.1)*Amax, Amax)
  
  # midpoints (used for calculating area occupied by each class; same as avg area in each class)
  #A <- c((Amin+A12)/2, (A23+A12)/2, (Amax+A23)/2)
  A <- (Abounds[1:10] + Abounds[2:11])/2
  
  # starting vectors for equilibration checks
  eq_check.1 <- c(0)
  eq_check.2 <- c(0)
  
  
  while(right-left > error_tol){ # while the difference btw the upper and lower values is 
    # greater than the error tolerance
    
    # calculate the midpoints
    # ternary search algorithm so divide range into thirds
    mid1 <- left + (right-left)/3 # add 1/3 of the range
    mid2 <- right - (right-left)/3 # subtract 1/3 of the range
    
    # run the model with phi = mid1 and mid2
    
    sim1 <- mod_fun10(tmax, P0, H0, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, 
                     eH, Apatch, z, phi = mid1)
    
    Ptot1 <- sum(sim1$P[,tmax])
    Htot1 <- sum(sim1$H[,tmax])
    HAtot1 <- sum(sim1$H[,tmax]*A)
    
    P_all1 <- sim1$P[,tmax]
    H_all1 <- sim1$H[,tmax]
    
    sim2 <- mod_fun10(tmax, P0, H0, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, 
                     eH, Apatch, z, phi = mid2)
    Ptot2 <- sum(sim2$P[,tmax])
    
    if(Ptot1 > Ptot2){ # if P abundance at the value to the left is greater than at the value to the right
      right <- mid2 # the max is to the left so make the rightmost point the right midpoint
    } else{
      left <- mid1 # otherwise the max is to the right so make the leftmost point the left midpoint
    }
    
    propH <- abs((sum(sim1$H[,tmax])-sum(sim1$H[,tmax-10]))/sum(sim1$H[,tmax-10]))
    Heq1 <- ifelse(propH > eqtol, 1, 0)
    
    propP <- abs((sum(sim1$P[,tmax])-sum(sim1$P[,tmax-10]))/sum(sim1$P[,tmax-10]))
    Peq1 <- ifelse(propP > eqtol, 1, 0)
    
    propH <- abs((sum(sim2$H[,tmax])-sum(sim2$H[,tmax-10]))/sum(sim2$H[,tmax-10]))
    Heq2 <- ifelse(propH > eqtol, 1, 0)
    
    propP <- abs((sum(sim2$P[,tmax])-sum(sim2$P[,tmax-10]))/sum(sim2$P[,tmax-10]))
    Peq2 <- ifelse(propP > eqtol, 1, 0)
    
    eq_check1 <- Heq1 + Peq1 # 0 if both equilibrated, 1 if one, 2 if neither
    eq_check2 <- Heq2 + Peq2
    
    # also check the system equilibrated
    eq_check.1 <- c(eq_check1, eq_check.1)
    eq_check.2 <- c(eq_check2, eq_check.2)
    
  }
  
  
  
  return(list(phi = mid1, P = Ptot1, HA = HAtot1, H = Htot1, P_all = P_all1, H_all = H_all1,
              eq_check.1 = eq_check.1, eq_check.2 = eq_check.2)) # return the midpoint and Ptot at the midpoint
  
}



# Resident and Invader model

RImod_fun10 <- function(tmax, R0, I0, H0, rP, nP, mP_pars, eP, phi, nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z){
  
  
  # unlist parameters
  # partner DD mortality
  K0 <- mP_pars$K0; slope_mP <- mP_pars$slope_mP
  
  # host dens-indep mortality
  a_n <- nH_pars$a_n; b_n <- nH_pars$b_n; c_n0 <- nH_pars$c_n0; exp_cn <- nH_pars$exp_cn; cn_mn <- nH_pars$cn_mn
  
  # host density dep mortality
  a_m <- mH_pars$a_m; b_m <- mH_pars$b_m; c_m <- mH_pars$c_m
  
  # host growth
  Dinf <- G_pars$Dinf; g0 <- G_pars$g0; exp_g <- G_pars$exp_g; g_mx <- G_pars$g_mx
  Dmin <- G_pars$Dmin
  
  # host fecundity
  Fmn <- F_pars$Fmn; Fconst <- F_pars$Fconst; Fexp <- F_pars$Fexp
  
  # calculate fixed parameters
  # boundaries of the host size classes
  Amax <- pi*(1/2*Dinf)^2
  Amin <- pi*(1/2*Dmin)^2
  
  Abounds <- c(Amin, seq(from = 0.1, to = 0.9, by = 0.1)*Amax, Amax)
  
  # midpoints (used for calculating area occupied by each class; same as avg area in each class)
  #A <- c((Amin+A12)/2, (A23+A12)/2, (Amax+A23)/2)
  A <- (Abounds[1:10] + Abounds[2:11])/2
  
  # partner density dependent mortality in each size class (depend on areas in each class)
  #mP <- c(avg_Pmort(Amin, A12, K0, slope_mP), avg_Pmort(A12, A23, K0, slope_mP), avg_Pmort(A23, Amax, K0, slope_mP))
  mP <- rep(NA, 10)
  for(aa in 1:10){
    mP[aa] <- avg_Pmort(Abounds[aa], Abounds[aa+1], K0, slope_mP)
  }
  
  # host fecundities in each size class
  #FH <- c(0, avg_fec(A12, A23, Fmn, Fconst, Fexp), avg_fec(A23, Amax, Fmn, Fconst, Fexp))
  FH <- rep(NA, 10)
  FH[1] <- 0
  for(aa in 2:10){
    FH[aa] <- avg_fec(Abounds[aa], Abounds[aa+1], Fmn, Fconst, Fexp)
  }
  
  # host density dependent mortality rates in each size class
  #mH <- c(avg_mort(Amin, A12, a_m, b_m, c_m), avg_mort(A12, A23, a_m, b_m, c_m), avg_mort(A23, Amax, a_m, b_m, c_m))
  mH <- rep(NA, 10)
  for(aa in 1:10){
    mH[aa] <- avg_mort(Abounds[aa], Abounds[aa+1], a_m, b_m, c_m)
  }
  
  # vector of time steps
  tset <- seq(from = 0, to = tmax, by = 1) # time steps for iterating over
  
  # holding matrices
  # host
  Hmat <- matrix(NA, nrow = length(A), ncol = length(tset))
  Hmat[ ,1] <- H0
  
  # partner (resident)
  Rmat <- matrix(NA, nrow = length(A), ncol = length(tset))
  Rmat[ ,1] <- R0
  
  # partner (invader)
  Imat <- matrix(NA, nrow = length(A), ncol = length(tset))
  Imat[ ,1] <- I0
  
  
  for(i in 2:length(tset)){ # for each timepoint
    
    # calculate the area occupied
    Atot <- sum(A*Hmat[, i-1])
    
    # calculate the host growth rates as a function of P per unit host
    g_i <- GofP(g0, exp_g, g_mx, (Rmat[, i-1] + Imat[, i-1])/Hmat[, i-1])
    
    # calculate size class transitions
    # class 1 to 2:
    # A0_1 <- S1ofA(A12, Dinf, g_i[1])
    # G12 <- ifelse(A0_1 < Amin, 1, (A12-A0_1)/(A12-Amin)) # proportion that grew into next size class
    # # if area at previous timestep is less than Amin, say 100% of class 1 grew to class 2
    # 
    # # class 2 to 3: 
    # A0_2 <- S1ofA(A23, Dinf, g_i[2])
    # G23 <- ifelse(A0_2 < A12, 1, (A23-A0_2)/(A23-A12)) # proportion that grew into next size class
    # # if area at previous timestep is in size class 1 (A02 < A12), say 100% of class 2 grew to class 3
    # 
    # G <- c(G12, G23, 0)
    
    G <- rep(NA, 10)
    G[10] <- 0
    
    for(aa in 1:9){
      A0_aa <- S1ofA(Abounds[aa+1], Dinf, g_i[aa])
      G[aa] <- ifelse(A0_aa < Abounds[aa], 1, (Abounds[aa+1]-A0_aa)/(Abounds[aa+1]-Abounds[aa]))
    }
    
    
    # calculate host dens-indep mortality rates as a function of P per host
    c_n <- MofP(c_n0, exp_cn, cn_mn, (Rmat[, i-1] + Imat[, i-1])/Hmat[, i-1])
    
    nH <- rep(NA, 10)
    for(aa in 1:10){
      nH[aa] <- avg_mort(Abounds[aa], Abounds[aa+1], a_n, b_n, c_n[aa])
    }
    
    # calculate the host growth and survival rates
    G_Ht <- G*max(0, 1-Atot/Apatch) # realized growth depends on how much room there is
    S_Ht <- exp(-(nH + mH*Atot/Apatch)) # mH*Atot/Apatch*Hmat[, i-1]
    
    # calculate the survival rates for the partner
    S_P <- rep(NA, 10)
    
    for(sss in 1:10){
      if(Hmat[sss,i-1] == 0){
        S_P[sss] <- 0
      } else{
        S_P[sss] <- exp(-(nP + mP[sss]*(Rmat[sss, i-1] + Imat[sss, i-1])/Hmat[sss,i-1])) # mortality depends on P/H
      }
    }
    
    # make the host transition matrix
    T_H <- matrix(rep(0, length(S_Ht)^2), nrow = length(S_Ht), ncol = length(S_Ht))
    # fill in the first row (note fecundities are done separately below)
    T_H[1, 1] <- (1-G_Ht[1])*S_Ht[1]
    
    # make the fish transition matrix
    T_P <- matrix(rep(0, length(S_Ht)^2), nrow = length(S_Ht), ncol = length(S_Ht))
    # fill in the first row
    T_P[1, 1] <- (1-G_Ht[1])*S_P[1]*S_Ht[1]
    
    
    # fill in the rest
    for(mm in 2:length(S_Ht)){
      
      # host
      T_H[mm, mm] <- (1-G_Ht[mm])*S_Ht[mm] # surviving and staying put
      T_H[mm, mm-1] <- G_Ht[mm-1]*S_Ht[mm-1] # surviving and growing to next size class
      
      # partner
      T_P[mm, mm] <- (1-G_Ht[mm])*S_P[mm]*S_Ht[mm] # surviving and staying put
      T_P[mm, mm-1] <- G_Ht[mm-1]*S_P[mm-1]*S_Ht[mm-1] # surviving and growing to next size class
    }
    
    # calculate the new population sizes
    Hmat[, i] <- T_H %*% Hmat[, i-1]
    Rmat[, i] <- T_P %*% Rmat[, i-1]
    Imat[, i] <- T_P %*% Imat[, i-1]
    
    
    
    # new partner recruits: distribute across the size classes according to preference function
    # total recruits (depends on whether population is open or closed)
    RRtot <- z*sum(rP*Rmat[ ,i-1]) + (1-z)*eP # resident recruits
    
    IRtot <- z*sum(rP*Imat[ ,i-1]) + (1-z)*eP # invader recruits
    
    # preferences
    
    if(sum(Hmat[, i-1])==0){ 
      pxset1 <- rep(0, 10)
      pxset2 <- rep(0, 10)
    } else{
      
      pxset1 <- phi_fun10(phi[1], A*Hmat[, i-1])
      pxset2 <- phi_fun10(phi[2], A*Hmat[, i-1])
      
    } 
    
    # calculate recruit survival
    S_R <- rep(NA, 10)
    
    for(sss in 1:10){
      if(Hmat[sss,i-1] == 0){ # index here needs to match index used for P/H (i or i-1)
        S_R[sss] <- 0
      } else{
        S_R[sss] <- exp(-(nP + mP[sss]*(Rmat[sss, i-1] + Imat[sss, i-1])/Hmat[sss, i-1]))
      }
    }
    
    # add new recruits 
    Rmat[, i] <- Rmat[, i] +  pxset1*RRtot*S_R 
    Imat[, i] <- Imat[, i] +  pxset2*IRtot*S_R 
    
    # add new recruits for the host (depends on whether population is open or closed)
    Hmat[1, i] <- Hmat[1, i] + z*sum(FH*Hmat[ ,i-1])*max(0, 1-Atot/Apatch) + (1-z)*eH*max(0, 1-Atot/Apatch)
    
    
    
    
  }
  
  
  
  return(list(t = tset, H = Hmat, R = Rmat, I = Imat))
  
}



# adaptive dynamics function

AD_fun10 <- function(n_mut, t_r, mut_size, tmax, R0, I0, H0, rP, nP, mP_pars, eP, phi, 
                    nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z, eqtol){
  
  
  # areas for calculating equilibrium host area
  # boundaries of the host size classes
  Dinf <- G_pars$Dinf
  Fmn <- F_pars$Fmn
  Amax <- pi*(1/2*Dinf)^2
  Amin <- pi*(1/2*Dmin)^2
  
  Abounds <- c(Amin, seq(from = 0.1, to = 0.9, by = 0.1)*Amax, Amax)
  
  # midpoints (used for calculating area occupied by each class; same as avg area in each class)
  #A <- c((Amin+A12)/2, (A23+A12)/2, (Amax+A23)/2)
  A <- (Abounds[1:10] + Abounds[2:11])/2
  
  
  # holding vectors and matrices
  phiR_set <- rep(NA, n_mut) # vector of values for evolving trait
  phiR_set[1] <- phi[1] # initial phi value for resident population
  
  # equilibrium resident and host population sizes (pre-invasion)
  Heqs <- matrix(NA, nrow = n_mut, ncol = 13) # total area, total number, H1, H2, H3,...H10, eq check
  Reqs <- matrix(NA, nrow = n_mut, ncol = 12) # total, R1, R2, R3, ...R10, eq check
  
  growth_check <- rep(NA, n_mut) # for checking whether both mutants grew
  
  
  # get the first equilibrium
  sim0 <- RImod_fun10(tmax, R0, I0 = rep(0, 10), H0, rP, nP, mP_pars, eP, phi, nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z)
  
  Heqs[1, 1:12] <- c(sum(sim0$H[,tmax]*A), sum(sim0$H[,tmax]), sim0$H[1:10,tmax])
  propH <- abs((sum(sim0$H[,tmax])-sum(sim0$H[,tmax-10]))/sum(sim0$H[,tmax-10]))
  Heqs[1, 13] <- ifelse(propH > eqtol, 1, 0)
  
  Reqs[1, 1:11] <- c(sum(sim0$R[,tmax]), sim0$R[1:10,tmax])
  propP <- abs((sum(sim0$R[,tmax])-sum(sim0$R[,tmax-10]))/sum(sim0$R[,tmax-10]))
  Reqs[1, 12] <- ifelse(propP > eqtol, 1, 0)
  
  for(i in 2:n_mut){ # for each mutation event
    
    # first get the equilibrium value of the (i-1)^th resident population (pre-invasion)
    # use Heqs[i-1, 3:5] and Reqs[i-1, 2:4] as the initial conditions - should be close to new eq
    
    sim0 <- RImod_fun10(tmax, R0 = Reqs[i-1, 2:11], I0 = rep(0, 10), H0 = Heqs[i-1, 3:12], rP, nP, mP_pars, eP, phi = c(phiR_set[i-1], phiR_set[i-1]), nH_pars, mH_pars,  G_pars, F_pars, eH, Apatch, z)
    
    # store the new equilibrium values
    Heqs[i, 1:12] <- c(sum(sim0$H[,tmax]*A), sum(sim0$H[,tmax]), sim0$H[1:10,tmax])
    propH <- abs((sum(sim0$H[,tmax])-sum(sim0$H[,tmax-10]))/sum(sim0$H[,tmax-10]))
    Heqs[i, 13] <- ifelse(propH > eqtol, 1, 0)
    
    Reqs[i, 1:11] <- c(sum(sim0$R[,tmax]), sim0$R[1:10,tmax])
    propP <- abs((sum(sim0$R[,tmax])-sum(sim0$R[,tmax-10]))/sum(sim0$R[,tmax-10]))
    Reqs[i, 12] <- ifelse(propP > eqtol, 1, 0)
    
    # now introduce mutants
    phiI.1 <- max(0, phiR_set[i-1] - mut_size)
    phiI.2 <- min(phiR_set[i-1] + mut_size, 1)
    
    # run simulations where each invades
    # use Heqs[i, 3:5] and Reqs[i, 2:4] as the initial conditions
    # phi = c(phiR_set[i-1], phiI.1) or c(phiR_set[i-1], phiI.2)
    sim_m1 <- RImod_fun10(t_r, R0 = Reqs[i, 2:11], I0, H0 = Heqs[i, 3:12], rP, nP,
                        mP_pars, eP, phi = c(phiR_set[i-1], phiI.1), nH_pars, mH_pars,
                        G_pars, F_pars, eH, Apatch, z)
    
    sim_m2 <- RImod_fun10(t_r, R0 = Reqs[i, 2:11], I0, H0 = Heqs[i, 3:12], rP, nP, 
                        mP_pars, eP, phi = c(phiR_set[i-1], phiI.2), nH_pars, mH_pars, 
                        G_pars, F_pars, eH, Apatch, z)
    
    # calculate the growth rate of the invader
    Itot.1 <- sim_m1$I[1,] + sim_m1$I[2,] + sim_m1$I[3,] + sim_m1$I[4,] + sim_m1$I[5,] + sim_m1$I[6,] + sim_m1$I[7,] + sim_m1$I[8,] + sim_m1$I[9,] + sim_m1$I[10,]
    Itot.2 <- sim_m2$I[1,] + sim_m2$I[2,] + sim_m2$I[3,] + sim_m2$I[4,] + sim_m2$I[5,] + sim_m2$I[6,] + sim_m2$I[7,] + sim_m2$I[8,] + sim_m2$I[9,] + sim_m2$I[10,]
    # s.1 <- max(0, avg_growth(Itot.1, sim_m1$t))
    # s.2 <- max(0, avg_growth(Itot.2, sim_m2$t))
    
    s.1 <- (Itot.1[t_r]-Itot.1[t_r-0.5*t_r])/Itot.1[t_r-0.5*t_r]
    s.2 <- (Itot.2[t_r]-Itot.2[t_r-0.5*t_r])/Itot.2[t_r-0.5*t_r]
    
    # determine which mutant fixes
    if(s.1 <= 0 && s.2 <= 0){ # if neither mutant grew
      phiR_set[i] <- phiR_set[i-1] # the resident trait doesn't change
      break # break the loop
      
    } else{ # if one of the mututants grew
      
      if(s.2 > s.1){ # if mutant 2's growth rate was higher
        # mutant 2 is the new resident trait
        phiR_set[i] <- phiI.2
      }
      
      if(s.1 > s.2){ # if mutant 1's growth rate was higher
        # mutant 1 is the new resident trait
        phiR_set[i] <- phiI.1
      }
      
      # check to see if both mutants grew
      if(s.1 > 0 && s.2 > 0){
        
        growth_check[i] <- s.1/s.2
        
      }
      
    }
    
    
  }
  
  
  return(list(phiR = phiR_set, Heqs = Heqs, Reqs = Reqs, growth_check = growth_check))
  
}



# function for calculating biomass-maximizing and ESS values of phi as a function of model pars

EcoEvo_fun10 <- function(par_choice, par_set, tmax, P0, H0, I0, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z, phi, phiRI){
  
  # holding vectors for the phi values
  eco_phi <- rep(NA, length(par_set))
  evo_phi <- rep(NA, length(par_set))
  
  # holding vectors for equilibration checks
  eco_eq <- rep(NA, length(par_set))
  evo_eq <- rep(NA, length(par_set))
  
  # holding vector for evo mutant growth checks
  evo_growth <- rep(NA, length(par_set))
  
  # holding lists for full outputs
  eco_list <- list()
  evo_list <- list()
  
  for(i in 1:length(par_set)){ # for each element in par_set
    
    
    # determine which parameter to change
    if(par_choice == "exp_g"){
      G_pars$exp_g <- par_set[i]
    }
    
    if(par_choice == "exp_cn"){
      nH_pars$exp_cn <- par_set[i]
    }
    
    if(par_choice == "g0"){
      G_pars$g0 <- par_set[i]
    }
    
    if(par_choice == "Fconst"){
      F_pars$Fconst <- par_set[i]
    }
    
    if(par_choice == "c_n0"){
      nH_pars$c_n0 <- par_set[i]
      nH_pars$a_n <- ac_mult*c_n0
    }
    
    if(par_choice == "rP"){
      rP <- par_set[i]
    }
    
    
    # eco sim
    
    # first get initial conditions (equilibrium with phi = 0.5)
    sim1 <- mod_fun10(tmax, P0, H0, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, 
                     eH, Apatch, z, phi = 0.5)
    
    P0.5 <- sim1$P[,tmax]
    H0.5 <- sim1$H[,tmax]
    
    # calculate the optimum phi value
    eco_opt <- phiTSA_fun10(left0, right0, error_tol, eqtol, tmax, P0.5, H0.5, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z, phi)
    
    eco_list[[i]] <- eco_opt
    eco_phi[i] <- eco_opt$phi
    eco_eq[i] <- sum(eco_opt$eq_check.1, eco_opt$eq_check.2)
    
    # for the eco sims, remember to get initial conditions first (see heatmap fun)
    evo_ess <- AD_fun10(n_mut, t_r, mut_size, tmax, R0 = P0, I0, H0, rP, nP, mP_pars, eP, 
                       phi = phiRI, nH_pars, mH_pars, G_pars, F_pars, eH, Apatch, z, eqtol)
    
    evo_list[[i]] <- evo_ess
    evo_eq[i] <- sum(evo_ess$Heqs[,13], evo_ess$Reqs[,12])
    evo_growth[i] <- length(which(is.na(evo_ess$growth_check)==F))
    
    if(is.na(evo_ess$phiR[n_mut]) == T){ # if last entry is NA, then stable value was reached before last mutation
      evo_phi[i] <- evo_ess$phiR[max(which(is.na(evo_ess$phiR)==F))]
    } else{
      
      if(length(unique(evo_ess$phiR[(n_mut-3):n_mut])) == 2){ # if bouncing btw two values, the last 4 entries should contain only 2 unique values
        
        evo_phi[i] <- mean(c(evo_ess$phiR[n_mut], evo_ess$phiR[n_mut-1]))
      } else{
        
        evo_phi[i] <- -9999
      }
      
    }
    
  }
  
  return(list(eco_list = eco_list, eco_phi = eco_phi, eco_eq = eco_eq, evo_list = evo_list,
              evo_phi = evo_phi, evo_eq = evo_eq, evo_growth = evo_growth))
  
}


```




# default parameters

```{r}

Amax <- pi*(50/2)^2 # max area of host
Fmn.10 <- 0.1*Amax # area at which the host becomes reproductively mature
Amin <- pi*(1/2)^2 # minimum host size
Apatch <- (Amax+0.9*Amax)/2*100 # size of patch

# size class boundaries
A_bounds10 <- c(Amin, seq(from = 0.1, to = 0.9, by = 0.1)*Amax, Amax)
A_mids10 <- (A_bounds10[1:10] + A_bounds10[2:11])/2 # used for calculating area occupied

# initial conditions
H010 <- rep(10, 10)
P010 <- rep(10, 10)


tmax <- 1000 # length of simulation; needs to be > 10 for the equilibration check to work

eqtol <- 0.001 # prop difference btw abundance at tmax and tmax - 10 needs to be less than eqtol to consider the simulation to have equilibrated


# HOST DENSITY INDEPENDENT MORTALITY

ac_mult <-3 # mortality rate of smallest individuals is c*(ac_mult + 1), mortality rate of infinitely large individuals is c

c_n0 <- 0.05 # maximum baseline asymptotic host density independent mortality rate (DI mortality rate of an infinitely large host)
a_n <- ac_mult*c_n0 # DI mortality of smallest individuals is a_n + c_n
b_n <- 0.005 # rate of decrease in host DI mortality rate with increasing host area
exp_cn <- 0 # rate at which the asymptotic host DI mortality rate decreases with increasing partner density (b_cn in the main text)
cn_mn <- 0.001 # lowest possible host DI mortality rate
  
# HOST DENSITY DEPENDENT MORTALITY
c_m <- 0.05 # asymptotic host density dependent mortality rate (DD mortality rate of an infinitely large host)
a_m <- ac_mult*c_m # DD mortality rate of smallest individuals is a_m + c_m
b_m <- 0.005 # rate of decrease in host DD mortality rate with increasing host area

# HOST GROWTH
Dinf <- sqrt(Amax/pi)*2 # Amax = pi*(1/2*Dinf)^2 so Dinf = sqrt(Amax/pi)*2
Dmin <- sqrt(Amin/pi)*2 # Amax = pi*(1/2*Dinf)^2 so Dinf = sqrt(Amax/pi)*2
g0 <- 0.025 # min host growth rate
exp_g <-  0 # rate of increase in host growth rate with increasing partner density (b_g in main text)
g_mx <- 0.1 # max host growth rate

# HOST FECUNDITY
Fconst <- 0.25 # fecundity of a host at maturation
Fexp <- 0.00025 # rate of increase in host fecundity with host area


# external host recruitment
eH <- 0

# PARTNER PARAMETERS
rP <- 1 # 1 # reproduction rate
nP <- 0.35 # density independent mortality rate
eP <- 0 # external partner recruitment

K0 <- 0.005 # baseline carrying capacity (inverse of baseline DD mortality rate)
slope_mP <- 0.0015 # rate of increase in host fecundity with host area

phi <- 0 # strength of preference for adult hosts

# OTHER PARAMETERS
z <- 1 # 1 = system is closed, 0 = system is open


# parameter lists for default simulation
mP_pars <- list(K0 = K0, slope_mP = slope_mP)
nH_pars <- list(a_n = a_n, b_n = b_n, c_n0 = c_n0, exp_cn = exp_cn, cn_mn = cn_mn)
mH_pars <- list(a_m = a_m, b_m = b_m, c_m = c_m)
G_pars <- list(Dinf = Dinf, g0 = g0, exp_g = exp_g, g_mx = g_mx, Dmin = Dmin)
F_pars.10 <- list(Fmn = Fmn.10, Fconst = Fconst, Fexp = Fexp)



# DEFAULT EQUILIBRIUM
dsim1 <- mod_fun10(tmax, P010, H010, rP, nP, mP_pars, eP, nH_pars, mH_pars, G_pars, F_pars.10, eH, Apatch, z, phi)

# dH1eq <- c(dsim1$H[1,tmax], dsim1$H[2,tmax], dsim1$H[3,tmax])
# dAeq <- sum(dsim1$H[ ,tmax]*c(Fmn.10/2, (0.9*Amax+Fmn.10)/2, (Amax+0.9*Amax)/2))

# check default
plot(x = dsim1$t, y = dsim1$H[1,], type = "l", ylim = c(0, max(as.vector(dsim1$H))), lty = 3, las = 1, xlab = "Time", ylab = "Host population size")
for(i in 2:10){
  lines(x = dsim1$t, y = dsim1$H[i,], lty = 1)
}

plot(x = dsim1$t, y = dsim1$P[1,], type = "l", ylim = c(0, max(as.vector(dsim1$P))), lty = 3, las = 1, xlab = "Time", ylab = "Partner population size")
for(i in 2:10){
  lines(x = dsim1$t, y = dsim1$P[i,], lty = 1)
}


dsim1$H[,tmax]

dsim1$P[,tmax]

PH_def <- dsim1$P[,tmax]/dsim1$H[,tmax]
PH_def

#phi_fun(phi = 1, Amax, A_mids, dsim1$H[,tmax]*A_mids)

```






```{r}
# get the partner maximizing and ESS phi values for the default parameter combinations

R0.10 <- rep(10, 10)
H0.10 <- rep(10, 10)
I0.10 <- c(0.003, 10)

# evolution parameters
t_r <- 36 # calculate invader growth rate over first 3 years
mut_size <- 0.005 
n_mut <- ceiling((1-0)/mut_size) # number of mutation events (make sure this is big enough that you can go from 0 to 1 in intervals of mut_size)

phiRI <- c(0, 0) # initial phi values

# eco opt parameters
left0 <- 0
right0 <- 1
error_tol <- 0.001
eqtol <- 0.001

# nutrition mutualism
G_pars.10 <- G_pars
G_pars.10$exp_g <- 1
nH_pars.10 <- nH_pars
nH_pars.10$exp_cn <- 0

#par_choice, par_set, tmax, P0 = R0.0, H0 = H0.0, I0 = I0.1, rP, nP, mP_pars.1, eP, nH_pars.1, mH_pars, G_pars.1, F_pars, eH, Apatch, z, phi, phiRI

ecoevoNdef10 <- EcoEvo_fun10(par_choice = "exp_g", par_set = c(1), tmax, P0 = R0.10, H0 = H0.10, I0 = I0.10, rP, nP, mP_pars, eP, nH_pars.10, mH_pars, G_pars.10, F_pars.10, eH, Apatch, z, phi, phiRI)

ecoNdef10 <- mod_fun10(tmax, P0 = R0.10, H0 = H0.10, rP, nP, mP_pars, eP, nH_pars.10, mH_pars, G_pars.10, F_pars.10, eH, Apatch, z, phi = ecoevoNdef10$eco_phi)


# defense mutualism
G_pars.10 <- G_pars
G_pars.10$exp_g <- 0
nH_pars.10 <- nH_pars
nH_pars.10$exp_cn <- 1

ecoevoDdef10 <- EcoEvo_fun10(par_choice = "exp_cn", par_set = c(1), tmax, P0 = R0.10, H0 = H0.10, I0 = I0.10, rP, nP, mP_pars, eP, nH_pars.10, mH_pars, G_pars.10, F_pars.10, eH, Apatch, z, phi, phiRI)

ecoDdef10 <- mod_fun10(tmax, P0 = R0.10, H0 = H0.10, rP, nP, mP_pars, eP, nH_pars.10, mH_pars, G_pars.10, F_pars.10, eH, Apatch, z, phi = ecoevoDdef10$eco_phi)


# check for equilibration
ecoevoNdef10$eco_eq
ecoevoNdef10$evo_eq
ecoevoDdef10$eco_eq
ecoevoDdef10$evo_eq
```


```{r}
# check the phi values

ecoevoNdef10$eco_phi
ecoevoNdef10$evo_phi

ecoevoDdef10$eco_phi
ecoevoDdef10$evo_phi


```




```{r}

# check the optimization worked

# phi_set10 <- seq(from = 0, to = 1, length.out = 25)
# 
# 
# Ptot10 <- rep(NA, length(phi_set10))
# 
# G_pars.10 <- G_pars
# G_pars.10$exp_g <- 1
# nH_pars.10 <- nH_pars
# nH_pars.10$exp_cn <- 0
# 
# 
# for(i in 1:length(phi_set10)){
#   
# sim10i <- mod_fun10(tmax, P010, H010, rP, nP, mP_pars, eP, nH_pars.10, mH_pars, G_pars.10, F_pars.10, eH, Apatch, z, phi_set10[i])
# 
# Ptot10[i] <- sum(sim10i$P[,tmax])
#   
# }
# 
# 
# plot(x = phi_set10, y = Ptot10, type = "l")
# 
# which(Ptot10 == max(Ptot10))

```



```{r}

# process the results: want to make a bar plot like the main text figure (showing percent differences in equilibria)


mx_indxN <- max(which(is.na(ecoevoNdef10$evo_list[[1]]$phiR)==F))

allH_evoN <- ecoevoNdef10$evo_list[[1]]$Heqs[mx_indxN,3:12]

allH_ecoN <- ecoNdef10$H[,tmax]

# (eco-evo)/evo

pdiffN_10 <- (allH_ecoN-allH_evoN)/allH_evoN

mx_indxD <- max(which(is.na(ecoevoDdef10$evo_list[[1]]$phiR)==F))

allH_evoD <- ecoevoDdef10$evo_list[[1]]$Heqs[mx_indxD,3:12]

allH_ecoD <- ecoDdef10$H[,tmax]

# (eco-evo)/evo

pdiffD_10 <- (allH_ecoD-allH_evoD)/allH_evoD



#ecoevoNdef10$eco_list[[1]]$P
#ecoevoNdef10$evo_list[[1]]$Reqs[mx_indxN, 1]

PtotdiffN <- (ecoevoNdef10$eco_list[[1]]$P-ecoevoNdef10$evo_list[[1]]$Reqs[mx_indxN, 1])/ecoevoNdef10$evo_list[[1]]$Reqs[mx_indxN, 1]

# ecoevoNdef10$eco_list[[1]]$HA
# ecoevoNdef10$evo_list[[1]]$Heqs[mx_indxN, 1]

HAtotdiffN <- (ecoevoNdef10$eco_list[[1]]$HA-ecoevoNdef10$evo_list[[1]]$Heqs[mx_indxN, 1])/ecoevoNdef10$evo_list[[1]]$Heqs[mx_indxN, 1]

# ecoevoDdef10$eco_list[[1]]$P
# ecoevoDdef10$evo_list[[1]]$Reqs[mx_indxD, 1]
# 
# ecoevoDdef10$eco_list[[1]]$HA
# ecoevoDdef10$evo_list[[1]]$Heqs[mx_indxD, 1]

PtotdiffD <- (ecoevoDdef10$eco_list[[1]]$P-ecoevoDdef10$evo_list[[1]]$Reqs[mx_indxD, 1])/ecoevoDdef10$evo_list[[1]]$Reqs[mx_indxD, 1]

HAtotdiffD <- (ecoevoDdef10$eco_list[[1]]$HA-ecoevoDdef10$evo_list[[1]]$Heqs[mx_indxD, 1])/ecoevoDdef10$evo_list[[1]]$Heqs[mx_indxD, 1]

```




plot results

```{r}

Dcol <- "#7B8BA5"
Ncol <- "#B66A40"

r_w <- 0.3 # rectangle widths
r_x <- seq(from = 1, to = 23, by = 2)

allN_diff <- c(PtotdiffN, HAtotdiffN, pdiffN_10)
allD_diff <- c(PtotdiffD, HAtotdiffD, pdiffD_10)

#pdf("figures/barplot10.pdf", width = 8, height = 4)

par(mfrow = c(1, 1))
par(mar=c(0, 1.25, 0.5, 0), oma = c(4.5, 4.5, 2, 2.5))

plot(c(0, 24), c(-0.025*100, 50), pch = NA, xaxt = "n", yaxt = "n", las = 1, xlab = NA, ylab = NA)
abline(h = 0, col = "gray")
axis(side = 1, at = r_x, labels = c("No. of \npartners", "Host \ncover","H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10"), cex.axis = 0.75)
axis(side = 2, at = seq(from = 0, to = 60, by = 20), las = 1)
mtext(side = 1, "Abundance metric", line = 2.5)
mtext(side = 2, "% Difference between \n partner maximizing and ESS", line = 2.5)
for(i in 1:12){
# rect(xleft = r_x[i]-2*r_w, ybottom = 0, xright = r_x[i], ytop = pdiffN_10[i]*100, col = Ncol, border = Ncol)
# rect(xleft = r_x[i], ybottom = 0, xright = r_x[i]+2*r_w, ytop = pdiffD_10[i]*100, col = Dcol, border = Dcol)
rect(xleft = r_x[i]-2*r_w, ybottom = 0, xright = r_x[i], ytop = allN_diff[i]*100, col = Ncol, border = Ncol)
rect(xleft = r_x[i], ybottom = 0, xright = r_x[i]+2*r_w, ytop = allD_diff[i]*100, col = Dcol, border = Dcol)
}

legend("topleft", legend = c("Nutritional mutualism", "Defensive mutualism"), fill = c(Ncol, Dcol), bty = "n")

#dev.off()


```





